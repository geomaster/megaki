#include "common.h"

const byte MEGAKI_VERSION[] = { 0x0A, 0xFF };

const byte MEGAKI_ERROR_TOKEN[] = 
  { 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
    0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE };
  
const byte MEGAKI_INCOMPATIBLE_VERSIONS_ERROR[] = 
  { 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00 };
    
const byte MEGAKI_SERVICE_UNAVAILABLE_ERROR[] = 
  { 0x02, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00 };
    
int mgk_memeql(const byte* a, const byte* b, length_t count)
{
  int eql = 1;
  unsigned int i;
  for (i = 0; i < count; ++i)
    if (a[i] != b[i]) eql = 0;
  return(eql);
}

void mgk_fill_magic(byte* buf, magic_type type)
{
  buf[0] = 'M';
  buf[1] = 'G';
  buf[2] = 'K';
  buf[3] = 0xAA;
  buf[4] = 0xCA;
  switch (type) {
  case magic_syn: buf[5] = 0x01; break;
  case magic_synack: buf[5] = 0x02; break;
  case magic_ack: buf[5] = 0x03; break;
  case magic_msg: buf[5] = 0x04; break;
  case magic_restart: buf[5] = 0x05; break;
  default: buf[5] = 0xFF; break;
  }
}

magic_type mgk_check_magic(const byte* buf)
{
  if (buf[0] == 'M' && buf[1] == 'G' && buf[2] == 'K' &&
      buf[3] == 0xAA && buf[4] == 0xCA) {
    switch (buf[5]) {
    case 0x01: return magic_syn;
    case 0x02: return magic_synack;
    case 0x03: return magic_ack;
    case 0x04: return magic_msg;
    case 0x05: return magic_restart;
    default: return magic_invalid;
    }
  } else return magic_invalid;
}
