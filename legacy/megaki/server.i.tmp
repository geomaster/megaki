#include "common.h"
#include "tokenbank.h"
#include "hexdump.h"
#include <openssl/rsa.h>
#include <openssl/aes.h>
#include <openssl/rand.h>
#include <openssl/bn.h>
#include <openssl/pem.h>
#include <openssl/sha.h>
#include <openssl/err.h>
#include <assert.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>

#include <stdio.h>
#include <stdlib.h>

#define DOCUMENT_CONNECTIONS

#define MAGIC_BYTES               6
#define RSA_LIMIT                 (MEGAKI_RSA_KEYSIZE / 8 - 42)
#define SOCKET_BACKLOG            2048
#define QUEUE_BACKLOG             8192
#define CONFIG_MAXLINESIZE        16384
#define MAX_THREADS               4096
#define MAX_ARG_LENGTH            16384

#define RECEIVE_TIMEOUT           30
#define RECEIVE_FLAGS             (MSG_WAITALL)
#define SEND_FLAGS                (0)
#define SYN_LENGTH_NOHEAD         (MEGAKI_HASH_BYTES + 2 * MEGAKI_RSA_KEYSIZE / 8)
#define SYNACK_LENGTH_NOHEAD      (MEGAKI_TOKEN_BYTES + MEGAKI_HASH_BYTES + MEGAKI_AES_BLOCK_BYTES +
                                   AES_ENCRYPTED_SIZE(MEGAKI_TOKEN_BYTES + MEGAKI_AES_CBC_KEYSIZE / 8))
#define SYN_LENGTH                (SYN_LENGTH_NOHEAD + MAGIC_BYTES)
#define SYNACK_LENGTH             (SYNACK_LENGTH_NOHEAD + MAGIC_BYTES)

#define MAX_TOKENS                100
#define LINGER_SECONDS            10
#define MAX_TOKEN_BUCKETS         (2*MAX_TOKENS)

#define MAX_MESSAGE_LENGTH        1024
#define DECRYPTION_BUF_LENGTH     512

#define MAX_CONNECTIONS           
int opt_daemonize;

uv_loop_t* loop;
uv_tcp_t servconn;

char* opt_port, *opt_addr, *opt_cert, *opt_cert_passphrase;
int opt_threads, opt_queuelength;

RSA * server_private;
/*
typedef struct worker_info {
  int socket;
  struct sockaddr* claddr;
  socklen_t claddr_size;
} worker_info;

worker_info *workers;
*/
/*
struct timeval tv;  
struct linger lin;
*/

void on_close(uv_handle_t* h)
{
  free(h);
}

void quit_connection(connection* c, int ret)
{
  uv_close(c->stream, on_close);
  if (c->client_public)
    RSA_free(client_public);
  free(c);
}

void onexit()
{
}

const char vowels[] = "AEIOU";
const char consonants[] = "BCDFGHJKLMNPQRSTVWXYZ";

typedef struct connection {
  byte token[MEGAKI_TOKEN_BYTES];
  RSA* client_public;
  
  AES_KEY server_symmetric,
          master_symmetric;
          
  uv_stream_t* stream;
  enum state {
    cs_wait_syn,
    cs_recv_syn,
    cs_wait_ack,
    cs_recv_ack,
    cs_msg_loop
  } conn_state;
# ifdef DOCUMENT_CONNECTIONS
  char conn_id[7];
# endif

  byte receive_buffer[MAX_MESSAGE_LENGTH];
  uint32_t received_length;

} connection;

void handle_syn(connection* c)
{
  printf("I saw a SYN.\n");
}

void handle_synack(connection* c)
{
  
}

uv_buf_t alloc_buffer(uv_handle_t* handle, size_t size) {
  return uv_buf_init((char*) malloc(size), size);
}

void on_read(uv_stream_t* stream, ssize_t nread, uv_buf_t buf)
{
  connection* c = (connection*)stream->data;
  if (nread == -1) {
    uv_close((uv_handle_t*)stream, on_close);
    return;
  }
  
  ssize_t newlength = conn->received_length + nread;
  
  switch(c->conn_state) {
  case cs_wait_syn:
    if (newlength == SYN_LENGTH) {
      memcpy(conn->receive_buffer + conn->received_length, buf.base, nread);
      c->conn_state = cs_recv_syn;
      handle_syn(c);
    } else if (newlength > SYN_LENGTH) {
      /* ignore bogus data */
    } else {
      memcpy(conn->receive_buffer + conn->received_length, buf.base, nread);
    }
    
    break;
    
  case cs_recv_syn:
    break;
    
  case cs_wait_synack:
    if (newlength == SYNACK_LENGTH) {
      memcpy(conn->receive_buffer + conn->received_length, buf.base, nread);
      c->conn_state = cs_recv_syn;
      handle_synack(c);
    } else if (newlength > SYNACK_LENGTH) {
      /* ignore bogus data */
    } else {
      memcpy(conn->receive_buffer + conn->received_length, buf.base, nread);
    }
  };
  
  
}

void on_connect(uv_stream_t* server, int status)
{
  if (status == -1) {
    #ifdef DOCUMENT_CONNECTIONS
    fprintf(stderr, "[HYPRVS] connection attempt fail\n");
    return;
    #endif
  }
  uv_tcp_t* client = malloc(sizeof(uv_tcp_t));
  if (uv_tcp_init(loop, client) == -1) {
    #ifdef DOCUMENT_CONNECTIONS
    fprintf(stderr, "[HYPRVS] uv_tcp_init fail\n");
    #endif 
    free(client);   
    return;
  }
  
  if (uv_accept(server, (uv_stream_t*)client) == 0) {
    int connsocket = client->accepted_fd; /* AH HA HA HA BREAKING MULTIPLATFORM CODE */
    setsockopt(connsocket, SOL_SOCKET, SO_RCVTIMEO, (char*)&tv, sizeof(struct timeval));
    setsockopt(connsocket, SOL_SOCKET, SO_LINGER, &lin, sizeof(lin));

    /*byte buffer[MAX_MESSAGE_LENGTH], decbuffer[DECRYPTION_BUF_LENGTH], mac[MEGAKI_HASH_BYTES],
         tokstr[MEGAKI_TOKEN_BYTES];*/
         
    connection *c = malloc(sizeof(connection));
    (uv_handle_t*)server->data = c;
    c->stream = server;
    
    #ifdef DOCUMENT_CONNECTIONS
    char cons[7];
    int consi;
    for (consi = 0; consi < 6; ++consi) {
      if (consi % 2 == 0)
        cons[consi] = consonants[rand() % (sizeof consonants - 1)];
      else cons[consi] = vowels[rand() % (sizeof vowels - 1)];
    }
    cons[6] = '\0';
    memcpy(c->conn_id, cons, 7);
    fprintf(stderr, "[%s] opening connection\n", cons);
    #endif
    uv_read_start((uv_stream_t*)client, alloc_buffer, on_read);
  } else {
    uv_close((uv_handle_t*) client, on_close);
  }
}

#define CHECK(res, reason) \
  if ((res) == -1) { \
    fprintf(stderr, "fatal: %s\n", (reason)); \
    return(-1); \
  }
  
int server()
{
  int res;
  loop = uv_default_loop();
  
  struct sockaddr_in addr;
  if (uv_ip4_addr(opt_addr, atoi(opt_port), &addr) == -1) {
    fprintf(stderr, "fatal: could not resolve local address %s:%d\n", opt_addr, atoi(opt_port);
    return(-1);
  }
  
  res = uv_tcp_init(loop, &server);
  CHECK(res, "could not init libuv tcp");
  res = uv_tcp_bind(&server, addr);
  CHECK(res, "could not bind to local address");
  
  res = uv_listen((uv_stream_t*)&server, SOCKET_BACKLOG, on_connect);
  CHECK(res, "could not listen for connections");
  
  fprintf(stderr, "bound and listening on %s:%s\n", opt_addr, opt_port);
  return uv_run(loop, UV_RUN_DEFAULT);
}

void handle_signal(int s) {
  onexit();
  exit(0);
}

void process_option(char* s, int allow_config)
{
  char *left, *right, *p, *p1, *p2;
  size_t len, mode = 0;
  FILE * conf;
  
  len = strlen(s);
  if (len <= MAX_ARG_LENGTH) {
    left = (char*)malloc((len + 1) * sizeof(char));
    right = (char*)malloc((len + 1) * sizeof(char));
    
    if (left == NULL || right == NULL) {
      fprintf(stderr, "fatal: memory allocation failed. we shall not continue\n");
      exit(-1);
    }
    
    p1 = left;
    p2 = right;
    
    memset(left, 0, (len + 1) * sizeof(char));
    memset(right, 0, (len + 1) * sizeof(char));
    
    mode = 0;
    for (p = s; *p; ++p) {
      if (mode == 0 && *p == '=')
        mode = 1;
      else {
        if (mode == 0) 
          *p1++ = *p;
        else
          *p2++ = *p;
      }
    }
    
    len = strlen(left);
    if (!strcmp(left, "addr")) {
      opt_addr = right;
    } else if (!strcmp(left, "port")) {
      opt_port = right;
    } else if (!strcmp(left, "daemonize")) {
      opt_daemonize = atoi(right);
    } else if (!strcmp(left, "cert")) {
      opt_cert = right;
    } else if (!strcmp(left, "cert-passphrase")) {
      opt_cert_passphrase = right;
    } else if (!strcmp(left, "threads")) {
      opt_threads = atoi(right);
    } else if (!strcmp(left, "queue-length")) {
      opt_queuelength = atoi(right);
    } else if (allow_config && !strcmp(left, "config")) {
      conf = fopen(right, "r");
      if (!conf) {
        perror("fopen()");
        fprintf(stderr, "could not open config file\n");
      } else {
        char line[CONFIG_MAXLINESIZE];
        
        while (!feof(conf)) {
          memset(line, 0, sizeof(line));
          fgets(line, CONFIG_MAXLINESIZE * sizeof(char), conf);
          len = strlen(line);
          
          if (len) {
            line[len - 1] = '\0';
            process_option(line, 0);
          }
        }
        
        fclose(conf);
      }
    } else {
      fprintf(stderr, "Unknown option: %s\n", left);
      return;
    }
  }
  return;
}

void defaults()
{
  opt_daemonize = 1;
  opt_threads = 10;
  opt_queuelength = 40;
}

int main(int argc, char** argv)
{
  /*
  printf("testing token bank\n");
  tokinit();
  
  byte sth[MEGAKI_TOKEN_BYTES];
  tokentry* tokens[256];
  memset(sth, 0, MEGAKI_TOKEN_BYTES);
  int i;
  for (i = 0; i < 128; ++i) {
    sth[0] = i;
    int j = 10000000;
    while (j--);
    printf("byte %x\n", i);
    tokens[i] = tok_create(sth);
  }
  
  for (i = 255; i >= 128; --i) {
    sth[0] = i;
    int j = 10000000;
    while (j--);
    printf("byte %x\n", i);
    tokens[i] = tok_create(sth);
  }
  
  int i2 = 1;
  int j = 70000000 ;
  while(j--) i2 = 2 * i2 + 655 + j;
  
  for (i = 0; i < 254; ++i) {
    sth[0] = i;
    assert(tok_renew(sth) == tokens[i]);
  }
  
  return(0);*/
  char** arg;
  
  ERR_load_crypto_strings();
  OpenSSL_add_all_ciphers();
  if (!tokinit(MAX_TOKENS, MAX_TOKEN_BUCKETS)) {
    fprintf(stderr, "fatal: could not load the token bank\n");
    exit(-1);
  }
  
  defaults();
  for (arg = argv + 1; arg < argv + argc; ++arg) {
    process_option(*arg, 1);
  }
  
  tv.tv_sec = RECEIVE_TIMEOUT;
  tv.tv_usec = 0;
  
  lin.l_onoff = 1;
  lin.l_linger = LINGER_SECONDS;
  
  if (!opt_cert) {
    fprintf(stderr, "fatal: no certificate provided\n");
    return(-1);
  }
  
  FILE * f = fopen(opt_cert, "r");
  if (!f) {
    fprintf(stderr, "fatal: could not open certificate file '%s' for reading\n", opt_cert);
    return(-1);
  }
  
  if (PEM_read_RSAPrivateKey(f, &server_private, NULL, opt_cert_passphrase) == NULL) {
    fprintf(stderr, "fatal: failed reading PEM file: %s\n", ERR_reason_error_string(ERR_get_error()));
    return(-1);
  }

  srand(time(NULL));
  
  struct sigaction siginth;  
  siginth.sa_handler = handle_signal;
  sigemptyset(&siginth.sa_mask);
  siginth.sa_flags = 0;
  /*sigaction(SIGINT, &siginth, NULL);*/
  
  if (opt_daemonize) {
    if (fork() == 0) {
      return( server() );
    } else {
      return(0);
    }
  } else {
    return( server() );
  }
}

